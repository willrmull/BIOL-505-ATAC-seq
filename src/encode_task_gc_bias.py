#!/usr/bin/env python

# Import necessary libraries
import warnings
from matplotlib import pyplot as plt
import sys
import os
import argparse
from encode_lib_common import (
    strip_ext_bam, ls_l, log, logging, rm_f)  # Utility functions for file handling
from encode_lib_genomic import (
    remove_read_group, locate_picard)  # Functions for genomic data processing
import numpy as np
import pandas as pd
import matplotlib as mpl
mpl.use('Agg')  # Set up matplotlib to use non-GUI Agg backend (good for server environments)

# Suppress warnings for cleaner output
warnings.filterwarnings("ignore")


def parse_arguments():
    """
    Parse command-line arguments to configure the script's execution.
    """
    parser = argparse.ArgumentParser(prog='ENCODE GC bias')
    
    # Add arguments for input files and parameters
    parser.add_argument('--nodup-bam', type=str,
                        help='Raw BAM file (from task filter).')  # Input BAM file
    parser.add_argument('--ref-fa', type=str, help='Reference fasta file.')  # Reference fasta file
    parser.add_argument('--picard-java-heap',
                        help='Picard\'s Java max. heap: java -jar picard.jar '
                             '-Xmx[MAX_HEAP]')  # Java heap memory size for Picard
    parser.add_argument('--out-dir', default='', type=str,
                        help='Output directory.')  # Output directory for results
    parser.add_argument('--log-level', default='INFO', help='Log level',
                        choices=['NOTSET', 'DEBUG', 'INFO', 'WARNING',
                                 'CRITICAL', 'ERROR', 'CRITICAL'])  # Logging level
    args = parser.parse_args()
    
    # Set logging level based on user's input
    log.setLevel(args.log_level)
    log.info(sys.argv)  # Log the arguments used for execution
    return args


def get_gc(qsorted_bam_file, reference_fasta, prefix, java_heap=None):
    '''
    Uses Picard tools to calculate GC bias metrics.
    The reference FASTA must match the one used to generate the Bowtie indices.
    Assumes Picard is already loaded into the environment (e.g., with module add picard-tools).
    '''
    
    # Remove redundant or malformed read group information from BAM file
    logging.info('Getting GC bias...')

    # Prepare output filenames
    output_file = '{0}.gc.txt'.format(prefix)
    plot_file = '{0}.gcPlot.pdf'.format(prefix)
    summary_file = '{0}.gcSummary.txt'.format(prefix)

    # Set Java heap memory parameter, default is 10G if not specified
    if java_heap is None:
        java_heap_param = '-Xmx10G'
    else:
        java_heap_param = '-Xmx{}'.format(java_heap)

    # Construct Picard command to calculate GC bias metrics
    get_gc_metrics = ('java {6} -XX:ParallelGCThreads=1 -jar '
                      '{5} '
                      'CollectGcBiasMetrics R={0} I={1} O={2} '
                      'USE_JDK_DEFLATER=TRUE USE_JDK_INFLATER=TRUE '
                      'VERBOSITY=ERROR QUIET=TRUE '
                      'ASSUME_SORTED=FALSE '
                      'CHART={3} S={4}').format(reference_fasta,
                                                qsorted_bam_file,
                                                output_file,
                                                plot_file,
                                                summary_file,
                                                locate_picard(),
                                                java_heap_param)
    
    # Log the Picard command for transparency
    logging.info(get_gc_metrics)
    
    # Execute the Picard command using the system shell
    os.system(get_gc_metrics)
    
    # Return paths to the generated output files
    return output_file, plot_file, summary_file


def plot_gc(data_file, prefix):
    '''
    Plots the GC bias metrics generated by Picard in a more visual format (PNG) for inclusion in reports.
    '''
    
    # Load data from the GC bias metrics output file
    data = pd.read_table(data_file, comment="#")  # Ignore comment lines (Picard output starts with '#')

    # Create the plot
    fig = plt.figure()
    ax = fig.add_subplot(111)

    # Set x-axis limits to range 0-100% GC content
    plt.xlim((0, 100))

    # Plot normalized coverage as a function of GC content
    lin1 = ax.plot(data['GC'], data['NORMALIZED_COVERAGE'],
                   label='Normalized coverage', color='r')
    ax.set_ylabel('Normalized coverage')

    # Create another axis to plot mean base quality at different GC levels
    ax2 = ax.twinx()  # Create a second y-axis
    lin2 = ax2.plot(data['GC'], data['MEAN_BASE_QUALITY'],
                    label='Mean base quality at GC%', color='b')
    ax2.set_ylabel('Mean base quality at GC%')

    # Create a third y-axis to plot normalized window count at each GC level
    ax3 = ax.twinx()
    lin3 = ax3.plot(data['GC'], data['WINDOWS']/np.sum(data['WINDOWS']),
                    label='Windows at GC%', color='g')
    ax3.get_yaxis().set_visible(False)  # Hide the third y-axis labels

    # Combine all three plots into a single legend
    lns = lin1 + lin2 + lin3
    labs = [l.get_label() for l in lns]
    ax.legend(lns, labs, loc='best')

    # Save the plot as a PNG image
    prefix = data_file.rstrip('.gc.txt')  # Remove the '.gc.txt' suffix
    plot_png = prefix + '.gc_plot.png'
    fig.savefig(plot_png, format='png')  # Save the figure as a PNG file

    # Return the path to the saved plot image
    return plot_png


def main():
    # Read command-line arguments
    args = parse_arguments()

    # Extract input parameters
    REF = args.ref_fa  # Reference fasta file
    FINAL_BAM = args.nodup_bam  # Input BAM file (deduplicated)
    OUTPUT_PREFIX = os.path.join(
        args.out_dir,
        os.path.basename(strip_ext_bam(FINAL_BAM)))  # Output file prefix based on input BAM file
    RG_FREE_FINAL_BAM = remove_read_group(FINAL_BAM)  # Remove read groups from BAM file
    JAVA_HEAP = args.picard_java_heap  # Java heap memory for Picard

    # Run the GC bias calculation with Picard tools
    gc_out, gc_plot_pdf, gc_summary = get_gc(RG_FREE_FINAL_BAM,
                                             REF,
                                             OUTPUT_PREFIX,
                                             JAVA_HEAP)
    # Generate the GC plot in PNG format from the Picard output
    plot_gc(gc_out, OUTPUT_PREFIX)

    # Clean up temporary files (remove BAM file with removed read groups)
    rm_f(RG_FREE_FINAL_BAM)

    # List all files in the output directory for reference
    log.info('List all files in output directory...')
    ls_l(args.out_dir)

    # Log that the script has completed
    log.info('All done.')


if __name__ == '__main__':
    main()  # Run the main function
